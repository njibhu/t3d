<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: LocalReader/ArchiveParser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: LocalReader/ArchiveParser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
Copyright © Tyria3DLibrary project contributors

This file is part of the Tyria 3D Library.

Tyria 3D Library is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Tyria 3D Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with the Tyria 3D Library. If not, see &lt;http://www.gnu.org/licenses/>.
*/

const MathUtils = require('../util/MathUtils');

/**
 * @file The ArchiveParser module is a set of helper tools to correctly read the Archive.
 * @namespace ArchiveParser
 */

/**
 *    All in one function to read a GW2.dat file and parse all the needed informations to work with it
 *
 * @memberof ArchiveParser
 * @param {File} file
 * @returns {Promise&lt;{archiveHeader: ArchiveHeader, metaTable: MetaTable, indexTable: IndexTable}>}
 */
async function readArchive(file){
    let archiveHeader = parseANDatHeader((await getFilePart(file, 0, 40)).ds);
    let mftData = parseMFTTable((await getFilePart(file, archiveHeader.mftOffset, archiveHeader.mftSize)).ds);
    let {ds, len} = await getFilePart(file, mftData.mftIndexOffset, mftData.mftIndexSize);
    let indexTable = parseMFTIndex(ds, len);

    return {
        archiveHeader: archiveHeader,
        metaTable: mftData.table,
        indexTable: indexTable
    };
}


/**
 * The header of the archive.
 * @typedef {Object} ArchiveHeader
 * @property {number} version
 * @property {number} magic
 * @property {number} headerSize
 * @property {number} chunkSize
 * @property {number} crc
 * @property {number} mftOffset
 * @property {number} mftSize
 * @property {number} flags
 */

/**
 *   Parse the main information about the archive like format version, positions of information tables, crc etc...
 * 
 * @memberof ArchiveParser
 * @param {DataStream} ds
 * @returns {ArchiveIndex} Returns undefined if the header couldn't be parsed
 */
function parseANDatHeader(ds){
    var header = {};

    // Header parsing
    header.version = ds.readUint8();
    header.magic = ds.readString(3);
    header.headerSize = ds.readUint32();
    ds.seek(ds.position + 4); //Skip uint32
    header.chunkSize = ds.readUint32();
    header.crc = ds.readUint32();
    ds.seek(ds.position + 4); //Skip uint32
    header.mftOffset = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);
    header.mftSize = ds.readUint32();
    header.flags = ds.readUint32();
    // End header parsing

    //Check MAGIC
    if(header.magic != "AN\u001A"){
        T3D.Logger.log(
            T3D.Logger.TYPE_ERROR, "ANDat header is not valid", header.magic);
        return undefined;
    }

    T3D.Logger.log(
        T3D.Logger.TYPE_DEBUG,
        "Loaded Main .dat header"
    );

    return header;
}

/**
 * The array containing all the meta information concerning the contained files
 * @typedef {Array&lt;{offset: number, size: number, compressed: number, crc: number}>} MetaTable
 */

/**
 *   Parse the main information table that contains the offset, size, compression flags and crc
 * 
 * @memberof ArchiveParser
 * @param {Datastream}  ds
 * @returns {{header: {magic: String, nbOfEntries: number}, table: MetaTable, mftIndexOffset: number, mftIndexSize: number}|undefined}
 *   Returns undefined if it couldn't parse the table
 */
function parseMFTTable(ds){
    // Parse the table header
    var header = {};
    header.magic = ds.readString(4);
    ds.seek(ds.position + 8) //Skip uint64
    header.nbOfEntries = ds.readUint32();
    ds.seek(ds.position + 4 + 4); //Skip uint32 * 2

    //check MAGIC
    if(header.magic != "Mft\u001A"){
        T3D.Logger.log(
            T3D.Logger.TYPE_ERROR, "MFTTable header is not valid", header.magic);
        return undefined;
    }

    //Where we put all the parsed data
    //We don't pre-alloc anymore since not having the data aligned together procs too many
    //cache misses during a fullscan
    let fullTable = [];
    
    // Go through the table
    for(let i=1; i&lt;header.nbOfEntries; i++){
        let item = {};
        item['offset'] = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);
        item['size'] = ds.readUint32();
        item['compressed'] = ds.readUint16();
        ds.seek(ds.position + 4 + 2); //Skip uint16 + uint32
        item['crc'] = ds.readUint32();
        fullTable[i] = item;
    }

    T3D.Logger.log(
		T3D.Logger.TYPE_DEBUG,
		"Loaded MFTTable"
	);

    return {
        header: header, 
        table: fullTable, 
        //Register the MFTIndex table position and size
        mftIndexOffset: fullTable[2].offset, 
        mftIndexSize: fullTable[2].size
    };
}


/**
 * The array linking all the file indexes to their respective files
 * @typedef {Array&lt;number>} IndexTable
 */

/**
 *   This function used to be much more complex with the use of
 *   a "fileId" which in the end was just the equivalent of 
 *   MFTbaseIds[mftId].sort().reverse()[0] (aka the bigger baseId found)
 * 
 * @memberof ArchiveParser
 * @param {DataStream} ds 
 * @param {number} size
 * @returns {IndexTable}
 */
function parseMFTIndex(ds, size){
    let length = size / 8;

    let indexTable = [];

    for(let i=0; i&lt;length; i++){
        //Parse table
        let id = ds.readUint32();
        let mftIndex = ds.readUint32();
        //Store the values
        indexTable[id] = mftIndex;
    }

    T3D.Logger.log(
		T3D.Logger.TYPE_DEBUG,
		"Finished indexing MFT"
	);

    return indexTable;
}


/**
 *   Get a chunk of the specified file. Used mainly to take parts of the Archive before parsing.
 * 
 * @memberof ArchiveParser
 * @param {File} file 
 * @param {number} offset 
 * @param {number} length 
 * @returns {Promise&lt;{ds: DataStream, len: number}>}
 */
function getFilePart(file, offset, length){
    return new Promise((resolve, reject) => {
        let reader = new FileReader();

        reader.onerror = reject;
    
        reader.onload = function(fileEvent){
            var buffer = fileEvent.target.result;
            var ds = new DataStream(buffer);
                ds.endianness = DataStream.LITTLE_ENDIAN;
            // Pass data stream and data length to callback function
            resolve({ds: ds, len: length});
        }
        
        // Slicing a File is just reducing the scope of the ArrayBuffer, but doesn't load anything in memory.
        reader.readAsArrayBuffer(file.slice(offset, offset + length));
    })
}

module.exports = {
    readArchive: readArchive,
    parseANDatHeader: parseANDatHeader,
    parseMFTTable: parseMFTTable,
    parseMFTIndex: parseMFTIndex,
    getFilePart: getFilePart
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-T3D.html">T3D</a></li></ul><h3>Classes</h3><ul><li><a href="DataReader.html">DataReader</a></li><li><a href="DataRenderer.html">DataRenderer</a></li><li><a href="EnvironmentRenderer.html">EnvironmentRenderer</a></li><li><a href="GW2Chunk.html">GW2Chunk</a></li><li><a href="GW2File.html">GW2File</a></li><li><a href="HavokRenderer.html">HavokRenderer</a></li><li><a href="LocalReader.html">LocalReader</a></li><li><a href="PersistantStore.html">PersistantStore</a></li><li><a href="PropertiesRenderer.html">PropertiesRenderer</a></li><li><a href="SingleModelRenderer.html">SingleModelRenderer</a></li><li><a href="StringRenderer.html">StringRenderer</a></li><li><a href="TerrainRenderer.html">TerrainRenderer</a></li><li><a href="ZoneRenderer.html">ZoneRenderer</a></li></ul><h3>Namespaces</h3><ul><li><a href="ArchiveParser.html">ArchiveParser</a></li><li><a href="FileTypes.html">FileTypes</a></li><li><a href="Logger.html">Logger</a></li><li><a href="MaterialUtils.html">MaterialUtils</a></li><li><a href="MathUtils.html">MathUtils</a></li><li><a href="ParserUtils.html">ParserUtils</a></li><li><a href="RenderUtils.html">RenderUtils</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun May 06 2018 14:40:58 GMT+0200 (Paris, Madrid (heure d’été))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
